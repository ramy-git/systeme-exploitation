#include <err.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <termios.h>

#include "carrefour.h"

sem_t light_sems[2];
sem_t add_car_sem;

struct carrefour_data data;

////////////////////////////////////////////////////////////////:
//// UTILITIES
////////////////////////////////////////////////////////////////:

/**
 * Utility function which sleep a random amount of time (in range [0; opt.automatic]).
 * Used by car creation loop.
 */
void random_sleep(void)
{
    int time = rand() % data.opt.automatic;
    usleep(1000 * time);
}

/**
 * Utility function which turn on a traffic light
 *
 * \param light to turn on
 */
void set_traffic_light(int time, int light)
{
    if (light == 0)
        printf("[%ds] \033[0;32mFeu 1, \033[0;31mFeu 2 \033[0mlibération de %d voitures\n", time, data.counts[light]);
    else
        printf("[%ds] \033[0;31mFeu 1, \033[0;32mFeu 2 \033[0mlibération de %d voitures\n", time, data.counts[light]);

    for (int i = 0; i < data.counts[light]; i++)
        sem_post(&light_sems[light]);

    data.counts[light] = 0;
}

/**
 * Utility function which adds a new car and create a watcher thread for it.
 *
 * \param id ID (name) of the car
 * \param light Traffic light / road associated to car
 */
void create_new_car(int id, int light)
{
    data.counts[light]++;

    printf("\t+ voiture %d sur la voie %d\n", id, light);

    pthread_t thread;
    struct car_data *dt = malloc(sizeof(*dt));

    dt->id = id;
    dt->light = light;

    if (pthread_create(&thread, NULL, wait_light_loop, dt)) {
        err(1, "cannot create thread");
    }

    pthread_detach(thread); // avoid zombies
}

/**
 * Utility function that checks if there is input is STDIN
 * \return boolean
 */
int has_input()
{
    struct timeval tv = { 0L, 0L };
    fd_set fds;
    FD_ZERO(&fds);
    FD_SET(STDIN_FILENO, &fds);
    return select(1, &fds, NULL, NULL, &tv);
}

////////////////////////////////////////////////////////////////:
//// MAIN LOOPS
////////////////////////////////////////////////////////////////:

/**
 * Waits for a car to pass. Should be executed in a separated thread
 * \param data `struct car_data`
 * \return NULL
 */
void *wait_light_loop(void *data)
{
    struct car_data *pt = data;

    sem_wait(&light_sems[pt->light]);
    printf("\t- la voiture %d est passée\n", pt->id);

    free(pt);

    return NULL;
}

/**
 * Automatic loop for new cars. Should be executed in a separated thread.
 * \param unused unused parameter for pthread
 * \return NULL
 */
void *new_car_loop(void *unused)
{
    (void) unused; // drop unused warning

    int added = 0;

    while (!data.opt.max_car || added < data.opt.max_car)
    {
        random_sleep();

        // lock car counter
        sem_wait(&add_car_sem);

        create_new_car(++added, data.light);

        // unlock car counter
        sem_post(&add_car_sem);
    }

    data.end = 1;

    return NULL;
}

/**
 * Interactive loop for new cars. Should be executed in a separated thread.
 * \param unused unused parameter for pthread
 * \return NULL
 */
void *new_car_interactive_loop(void *unused)
{
    (void) unused; // drop unused warning

    int added = 0;

    struct termios old, new;

    tcgetattr(STDIN_FILENO, &old);
    new = old;

    cfmakeraw(&new);

    while (!data.end && (!data.opt.max_car || added < data.opt.max_car))
    {
        int sleep = 1;

        // lock car counter
        sem_wait(&add_car_sem);

        tcsetattr(STDIN_FILENO, TCSANOW, &new);

        char c = has_input() ? getchar() : '\0';
        tcsetattr(STDIN_FILENO, TCSANOW, &old);

        if (c == '1')
            create_new_car(++added, 0);
        else if (c == '2')
            create_new_car(++added, 1);

        sem_post(&add_car_sem);

        if (sleep)
            usleep(5000);
    }

    data.end = 1;

    return NULL;
}

/**
 * Main loop which switchs between lights
 */
void traffic_light_loop()
{
    int time = 0;

    while (!data.end || data.counts[0] || data.counts[1])
    {
        // lock car counter
        sem_wait(&add_car_sem);

        data.light = 1 - data.light;
        set_traffic_light(time / 1000, data.light);

        // unlock car counter
        sem_post(&add_car_sem);

        time += data.opt.time;
        usleep(1000 * data.opt.time);
    }

    sem_post(&light_sems[1]);
    printf("===========================\n");
}

int main(int argc, char **argv)
{
    // init random
    srand(time(NULL));

    // init process data
    memset(&data, 0, sizeof(data));
    data.opt = parse_opts(argc, argv);

    // init semaphores
    if (sem_init(&light_sems[0], 0, 0) == -1
            || sem_init(&light_sems[1], 0, 0) == -1
            || sem_init(&add_car_sem, 0, 1) == -1)
        err(1, "cannot init semaphore");

    // create car creation thread
    pthread_t thread;

    if (pthread_create(&thread, NULL, data.opt.automatic == 0 ? new_car_interactive_loop : new_car_loop, NULL))
        err(1, "cannot create thread");

    // main loop
    traffic_light_loop();
    pthread_join(thread, NULL);

    return 0;
}
